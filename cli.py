# cli.py - Command Line Interface for Research Brief Generator
# WHY: This filename clearly indicates it's the CLI component of our system
# WHAT: A standalone script that users can run from terminal to generate research briefs

# WHY: Import argparse - Python's standard library for parsing command line arguments
# WHAT: argparse automatically handles --help, validates arguments, and provides user-friendly error messages
import argparse

# WHY: Import requests - HTTP library for making API calls to our FastAPI server
# WHAT: requests provides simple methods like .post(), .get() with automatic JSON handling
import requests

# WHY: Import sys - system-specific parameters and functions for handling program exit
# WHAT: sys.exit() allows us to terminate the program with specific exit codes (0=success, 1=error)
import sys

# WHY: Import time - time-related functions for measuring performance and duration
# WHAT: time.time() gives us timestamps to calculate how long operations take
import time

# WHY: Import json - for handling JSON data parsing and formatting
# WHAT: json.dumps() formats Python objects as pretty JSON strings for display
import json

# WHY: Define the base URL where our API server is running
# WHAT: This is the address our CLI will send HTTP requests to
# WHY: localhost:8000 is the default FastAPI development server address
# API_BASE_URL = "http://localhost:8000"
import os
API_BASE_URL = os.getenv("API_BASE_URL", "https://ai-research-assistant-production-1ef8.up.railway.app")

# WHY: Define a function to check if the API server is reachable

def check_api_health():
    """
    WHY: Check if the API server is running before making requests
    WHAT: Sends a GET request to /health endpoint to verify connectivity
    """
    try:
        # WHY: Send GET request to health endpoint with short timeout
        # WHAT: timeout=3 means give up after 3 seconds if no response
        response = requests.get(f"{API_BASE_URL}/health", timeout=3)
        
        # WHY: Check if HTTP status code indicates success (200 = OK)
        # WHAT: Any status code other than 200 means something went wrong
        if response.status_code == 200:
            return True
        else:
            return False
            
    except requests.RequestException:
        # WHY: Catch any network errors, connection failures, or timeouts
        # WHAT: RequestException is the base class for all requests library errors
        return False

def format_brief_output(brief_data):
    """
    WHY: Format the research brief data in a readable, professional way
    WHAT: Takes raw JSON data and converts it to nicely formatted terminal output
    """
    
    # WHY: Extract the brief object from the API response data
    # WHAT: .get() safely retrieves the 'brief' key, returns {} if not found
    brief = brief_data.get('brief', {})
    
    # WHY: Create a formatted string with clear sections and visual separators
    # WHAT: f-strings allow us to embed variables directly in string literals
    output = []
    
    # WHY: Add a visual separator to make output sections clear
    # WHAT: "=" * 60 creates a line of 60 equals signs for visual separation
    output.append("=" * 60)
    output.append("ğŸ‰ RESEARCH BRIEF COMPLETED")
    output.append("=" * 60)
    
    # WHY: Display the brief ID for tracking and reference purposes
    # WHAT: brief_id is unique identifier generated by our API for this request
    output.append(f"ğŸ“‹ Brief ID: {brief_data.get('brief_id', 'N/A')}")
    
    # WHY: Show the research topic so user can confirm it's correct
    # WHAT: This should match exactly what the user requested
    output.append(f"ğŸ¯ Topic: {brief.get('topic', 'N/A')}")
    
    # WHY: Display the research depth level (1-5 scale)
    # WHAT: Indicates how thorough the research was
    output.append(f"ğŸ“Š Depth: {brief.get('depth', 'N/A')}/5")
    
    # WHY: Add spacing for readability
    # WHAT: Empty string creates a blank line in the output
    output.append("")
    
    # WHY: Display the executive summary with clear labeling
    # WHAT: Executive summary is the high-level overview of findings
    output.append("ğŸ“ EXECUTIVE SUMMARY:")
    output.append(brief.get('executive_summary', 'No summary available'))
    output.append("")
    
    # WHY: List all key findings with numbered formatting
    # WHAT: Key findings are the most important discoveries from the research
    output.append("ğŸ” KEY FINDINGS:")
    
    # WHY: Iterate through key findings with enumerate to add numbers
    # WHAT: enumerate(list, 1) gives us (1, item1), (2, item2), etc.
    for idx, finding in enumerate(brief.get('key_findings', []), 1):
        # WHY: Format each finding with number and indentation for readability
        # WHAT: f-string includes the index number and finding text
        output.append(f"   {idx}. {finding}")
    
    output.append("")
    
    # WHY: Display information about sources used in the research
    # WHAT: Sources show where the information came from for credibility
    sources = brief.get('sources', [])
    output.append(f"ğŸ“š SOURCES ({len(sources)}):")
    
    # WHY: Loop through each source to display title and URL
    # WHAT: Users can verify sources and explore further if needed
    for idx, source in enumerate(sources, 1):
        # WHY: Format source with number, title, and URL for easy reference
        # WHAT: Shows both human-readable title and clickable URL
        title = source.get('title', 'Unknown Title')
        url = source.get('url', 'No URL')
        output.append(f"   {idx}. {title}")
        output.append(f"      ğŸ”— {url}")
    
    output.append("")
    
    # WHY: Show performance metrics so users understand system speed
    # WHAT: Processing time indicates how long the AI took to complete the research
    processing_time = brief_data.get('processing_time', 0)
    output.append(f"â±ï¸  Processing Time: {processing_time}s")
    
    # WHY: Add final separator for clean output formatting
    # WHAT: Visually closes the output section
    output.append("=" * 60)
    
    # WHY: Join all output lines with newlines to create final formatted string
    # WHAT: '\n'.join() combines list elements with newline characters between them
    return '\n'.join(output)

def generate_brief_interactive():
    """
    WHY: Provide an interactive mode where users can input data step-by-step
    WHAT: Alternative to command-line arguments for user-friendly interaction
    """
    
    print("ğŸ¤– Research Brief Generator - Interactive Mode")
    print("=" * 50)
    
    # WHY: Get research topic from user with input validation
    # WHAT: input() pauses execution and waits for user to type something
    while True:
        topic = input("ğŸ“ Enter research topic: ").strip()
        
        # WHY: Validate that topic is not empty and meets minimum length
        # WHAT: len() counts characters, ensures user provided meaningful input
        if len(topic) >= 5:
            break
        else:
            # WHY: Provide helpful error message and retry
            # WHAT: User gets clear feedback about what went wrong
            print("âŒ Topic must be at least 5 characters long. Please try again.")
    
    # WHY: Get research depth with validation and default value
    # WHAT: Depth determines how comprehensive the research should be
    while True:
        depth_input = input("ğŸ“Š Enter research depth (1-5, default 3): ").strip()
        
        # WHY: Handle empty input by using default value
        # WHAT: If user just presses Enter, use sensible default
        if not depth_input:
            depth = 3
            break
        
        try:
            # WHY: Convert string input to integer and validate range
            # WHAT: int() converts string to number, may raise ValueError
            depth = int(depth_input)
            
            # WHY: Check if depth is in valid range
            # WHAT: Our API only accepts depth values between 1 and 5
            if 1 <= depth <= 5:
                break
            else:
                print("âŒ Depth must be between 1 and 5. Please try again.")
        except ValueError:
            # WHY: Handle case where user enters non-numeric input
            # WHAT: ValueError is raised when int() can't convert the string
            print("âŒ Please enter a number between 1 and 5.")
    
    # WHY: Get user ID for tracking and personalization
    # WHAT: User ID helps our system track requests and provide personalized responses
    while True:
        user_id = input("ğŸ‘¤ Enter your user ID: ").strip()
        
        # WHY: Validate that user ID is not empty
        # WHAT: User ID is required by our API schema
        if len(user_id) >= 1:
            break
        else:
            print("âŒ User ID cannot be empty. Please try again.")
    
    # WHY: Ask about follow-up flag with simple yes/no input
    # WHAT: Follow-up affects how the AI processes the research request
    follow_up_input = input("ğŸ”„ Is this a follow-up query? (y/N): ").strip().lower()
    
    # WHY: Convert user input to boolean value
    # WHAT: Any input starting with 'y' is treated as yes, everything else as no
    follow_up = follow_up_input.startswith('y')
    
    # WHY: Add interactive prompt for summary length
    # WHAT: Guides users through length selection
    while True:
        length_input = input("ğŸ“ Enter desired summary length in words (50-2000, default 300): ").strip()
        
        if not length_input:
            summary_length = 300  # WHY: Default for empty input
            break
        
        try:
            summary_length = int(length_input)
            if 50 <= summary_length <= 2000:
                break
            else:
                print("âŒ Length must be between 50 and 2000 words. Please try again.")
        except ValueError:
            print("âŒ Please enter a valid number.")

    # WHY: Return all collected inputs as a dictionary
    # WHAT: This data structure matches what our API expects
    return {
        "topic": topic,
        "depth": depth,
        "user_id": user_id,
        "follow_up": follow_up,
        "summary_length": summary_length  # â† NEW: Include length in request
    }

def main():
    """
    WHY: Main entry point for the CLI application
    WHAT: Coordinates argument parsing, API calls, and output formatting
    """
    
    # WHY: Create argument parser with description for --help output
    # WHAT: ArgumentParser handles all command-line argument processing
    parser = argparse.ArgumentParser(
        # WHY: Description appears in help text to explain what this tool does
        description="AI-powered research brief generator - creates comprehensive research reports",
        
        # WHY: Epilog appears at bottom of help text with usage examples
        epilog="Example: python cli.py --topic 'AI in healthcare' --depth 4 --user john_doe"
    )
    
    # WHY: Add --topic argument as required string parameter
    # WHAT: required=True means user must provide this argument or get error
    parser.add_argument(
        '--topic', 
        type=str, 
        required=False,  # WHY: Made optional to support interactive mode
        help='Research topic to investigate (e.g., "artificial intelligence in medicine")'
    )
    
    # WHY: Add --depth argument with validation and default value
    # WHAT: choices=range(1,6) restricts input to integers 1,2,3,4,5 only
    parser.add_argument(
        '--depth', 
        type=int, 
        choices=range(1, 6), 
        default=3,
        help='Research depth level (1=basic, 2=light, 3=medium, 4=detailed, 5=comprehensive)'
    )
    
    # WHY: Add --user argument for tracking and personalization
    # WHAT: User ID helps API track requests and provide personalized responses
    parser.add_argument(
        '--user', 
        type=str, 
        required=False,  # WHY: Made optional to support interactive mode
        help='Your user ID for tracking (e.g., "john_doe_123")'
    )
    
    # WHY: Add --follow-up flag using store_true action
    # WHAT: store_true means presence of flag sets value to True, absence sets False
    parser.add_argument(
        '--follow-up', 
        action='store_true',
        help='Indicate this is a follow-up to previous research'
    )

    # WHY: Add summary length argument with validation
    # WHAT: Allows users to customize output length from command line
    parser.add_argument(
        '--length', 
        type=int, 
        default=300,
        choices=range(50, 2001),  # WHY: Validate range 50-2000 words
        help='Summary length in words (50-2000, default: 300)'
    )
    
    # WHY: Add --interactive flag for interactive mode
    # WHAT: Allows users to choose between command-line args and interactive prompts
    parser.add_argument(
        '--interactive', '-i',
        action='store_true',
        help='Run in interactive mode (prompts for all inputs)'
    )
    
    # WHY: Add --json flag for machine-readable output
    # WHAT: Useful when CLI is called by other programs that need structured data
    parser.add_argument(
        '--json',
        action='store_true', 
        help='Output results in JSON format instead of human-readable format'
    )
    
    # WHY: Parse command line arguments into namespace object
    # WHAT: args object contains all the arguments user provided
    args = parser.parse_args()
    
    # WHY: Check if user wants interactive mode
    # WHAT: Interactive mode is more user-friendly for manual use
    if args.interactive:
        # WHY: Get user inputs through interactive prompts
        # WHAT: generate_brief_interactive() handles all user interaction
        request_data = generate_brief_interactive()
    else:
        # WHY: Check if required arguments are provided in non-interactive mode
        # WHAT: topic and user are required for API call
        if not args.topic or not args.user:
            # WHY: Print helpful error message instead of cryptic parser error
            # WHAT: sys.stderr writes to error stream (separate from normal output)
            print("âŒ Error: --topic and --user are required in non-interactive mode", file=sys.stderr)
            print("ğŸ’¡ Tip: Use --interactive or -i for interactive mode", file=sys.stderr)
            print("ğŸ“– Use --help for usage information", file=sys.stderr)
            
            # WHY: Exit with code 1 to indicate error to calling program
            # WHAT: Exit code 0 = success, non-zero = error (standard convention)
            sys.exit(1)
        
        # WHY: Build request data from command line arguments
        # WHAT: Create dictionary matching our API's expected input format
        request_data = {
            "topic": args.topic,
            "depth": args.depth,
            "user_id": args.user,
            "follow_up": args.follow_up
        }
    
    # WHY: Check if API server is running before attempting request
    # WHAT: Provides better error message than generic connection failure
    print("ğŸ” Checking API connectivity...")
    if not check_api_health():
        # WHY: Provide helpful error message with troubleshooting tips
        # WHAT: Users get actionable information instead of confusing error
        print("âŒ Cannot connect to API server", file=sys.stderr)
        print(f"ğŸ’¡ Make sure the server is running at {API_BASE_URL}", file=sys.stderr)
        print("ğŸš€ Start server with: python api.py", file=sys.stderr)
        sys.exit(1)
    
    print("âœ… API server is responsive")
    
    # WHY: Display what we're about to do for user confirmation
    # WHAT: Shows the research parameters before starting expensive operation
    print(f"\nğŸ¯ Starting research brief generation...")
    print(f"   ğŸ“ Topic: '{request_data['topic']}'")
    print(f"   ğŸ“Š Depth: {request_data['depth']}/5")
    print(f"   ğŸ‘¤ User: {request_data['user_id']}")
    print(f"   ğŸ”„ Follow-up: {'Yes' if request_data['follow_up'] else 'No'}")
    print(f"   â±ï¸  Please wait, this may take 30-60 seconds...\n")
    
    try:
        # WHY: Record start time to measure total operation duration
        # WHAT: time.time() returns current timestamp as floating point seconds
        start_time = time.time()
        
        # WHY: Send POST request to our API with JSON payload
        # WHAT: requests.post() sends HTTP POST with automatic JSON encoding
        response = requests.post(
            f"{API_BASE_URL}/brief",    # WHY: URL endpoint for brief generation
            json=request_data,          # WHY: Automatically sets Content-Type: application/json
            timeout=120                 # WHY: 2-minute timeout for long-running AI operations
        )
        
        # WHY: Check HTTP status code to see if request succeeded
        # WHAT: 200 = success, 4xx = client error, 5xx = server error
        if response.status_code != 200:
            # WHY: Handle non-success status codes with helpful error messages
            # WHAT: Different status codes indicate different types of problems
            if response.status_code == 422:
                print("âŒ Invalid request data (validation error)", file=sys.stderr)
            elif response.status_code == 500:
                print("âŒ Server error occurred", file=sys.stderr)
            else:
                print(f"âŒ Request failed with status code: {response.status_code}", file=sys.stderr)
            
            # WHY: Try to show error details from API response
            # WHAT: API may include helpful error messages in response body
            try:
                error_data = response.json()
                if 'detail' in error_data:
                    print(f"ğŸ“‹ Details: {error_data['detail']}", file=sys.stderr)
            except:
                # WHY: If JSON parsing fails, just continue (error already reported)
                # WHAT: Don't let secondary error hide the main error
                pass
            
            sys.exit(1)
        
        # WHY: Parse JSON response from API
        # WHAT: Convert JSON string back to Python dictionary
        response_data = response.json()
        
        # WHY: Check if API reported success in the response data
        # WHAT: Our API returns success flag even with 200 status code
        if not response_data.get('success', False):
            # WHY: API can return 200 but still report internal failure
            # WHAT: This handles graceful error reporting from our API
            error_message = response_data.get('error', 'Unknown error occurred')
            print(f"âŒ API Error: {error_message}", file=sys.stderr)
            sys.exit(1)
        
        # WHY: Calculate total elapsed time for performance reporting
        # WHAT: Shows user how long the entire operation took
        end_time = time.time()
        total_time = end_time - start_time
        
        # WHY: Check if user wants JSON output format
        # WHAT: JSON output is useful for integration with other tools
        if args.json:
            # WHY: Use json.dumps with indentation for readable JSON output
            # WHAT: indent=2 makes JSON pretty-printed with 2-space indentation
            print(json.dumps(response_data, indent=2))
        else:
            # WHY: Use our custom formatting function for human-readable output
            # WHAT: format_brief_output() creates nicely formatted terminal display
            formatted_output = format_brief_output(response_data)
            print(formatted_output)
            
            # WHY: Add total time information at the end
            # WHAT: Includes both API processing time and network/overhead time
            api_time = response_data.get('processing_time', 0)
            print(f"\nâ±ï¸  Total Time: {total_time:.2f}s (API: {api_time}s, Network: {total_time-api_time:.2f}s)")
        
        # WHY: Exit with success code 0
        # WHAT: Indicates to calling program that operation completed successfully
        sys.exit(0)
        
    except requests.Timeout:
        # WHY: Handle timeout errors separately with specific message
        # WHAT: Timeout means request took longer than our 120-second limit
        print("âŒ Request timed out (operation took longer than 2 minutes)", file=sys.stderr)
        print("ğŸ’¡ Try reducing research depth or try again later", file=sys.stderr)
        sys.exit(1)
        
    except requests.ConnectionError:
        # WHY: Handle connection errors (server not running, network issues)
        # WHAT: ConnectionError means we couldn't establish connection to server
        print("âŒ Cannot connect to API server", file=sys.stderr)
        print(f"ğŸ’¡ Make sure server is running at {API_BASE_URL}", file=sys.stderr)
        sys.exit(1)
        
    except requests.RequestException as e:
        # WHY: Handle any other requests-related errors
        # WHAT: RequestException is base class for all requests library errors
        print(f"âŒ Request failed: {str(e)}", file=sys.stderr)
        sys.exit(1)
        
    except KeyboardInterrupt:
        # WHY: Handle Ctrl+C gracefully instead of showing ugly stack trace
        # WHAT: KeyboardInterrupt is raised when user presses Ctrl+C
        print("\nâŒ Operation cancelled by user", file=sys.stderr)
        sys.exit(1)
        
    except Exception as e:
        # WHY: Catch any unexpected errors to provide user-friendly message
        # WHAT: Prevents users from seeing confusing Python stack traces
        print(f"âŒ Unexpected error: {str(e)}", file=sys.stderr)
        print("ğŸ’¡ Please report this error if it persists", file=sys.stderr)
        sys.exit(1)

# WHY: This block only runs when script is executed directly (not imported)
# WHAT: Standard Python pattern for making scripts both importable and executable
if __name__ == '__main__':
    main()
